# 第十周复习参考



## TDD的三大定律

#### 测试驱动开发的工作遵循三个定律：

除非我们之前编写过失败的测试，否则我们不允许编写生产代码

我们不能在测试中编写比使测试失败所需的更多代码。如果测试未编译，则视为失败

这不应该从字面上理解。我们不能只输入一个字母然后说，失败！关键是我们在测试中写下一个类或方法名称，由于它还不存在编译失败，然后我们创建类或方法。换句话说：必须可以通过编写高效的代码来弥补测试的失败。

我们不能编写比使当前失败的测试工作所需的更高效的代码。

规则设定的循环不断重复，直到我们想不出另一个失败的测试
### 有时同时更改测试和生产代码是不可避免的。什么时候有这种情况？
当我们需要对功能修改时

### 将 TDD 方法概述为流程图

编写测试，测试失败，编写方法，测试成功

# 任务 2：测试驱动开发的流派

## 我们已经了解了测试驱动开发的三个定律，并且看到这些定律与重构一起指定了一个开发周期

写一个失败的测试，

编写能尽快使测试变绿的高效代码，并且

通过重构提高代码质量。

## 一些词语

由内而外 vs. 由外  而内 在由内而外的测试中，我们从基本功能开始，然后逐步研究更复杂的功能。但是我们也可以反过来开始，首先为复杂的函数编写测试，然后再编写更小的组件。

Sociable vs. Solitary 假设我们要测试的方法调用其他类中的方法。在这里，我们可以决定是使用真正的类 (Sociable) 还是用测试替身 (Solitary) 替换其他类。在单独测试的情况下，SUT 实际上仅限于一类，而在社交测试中，也可以测试其他一些类。无论我们编写社交测试还是单独测试，我们都需要用存根替换我们需要控制测试的组件（我们上周看到了）。

前门与后门 在我们的营销应用程序中，我们已经看到了两种类型的断言。一方面，有断言检查返回值或对象的状态（通常作为 getter 的返回）。这些断言是使用 AssertJ 编写的。这种类型的测试称为前门测试（或结果/状态验证）。另一方面，我们看到了我们用 Mockito 编写的断言。这些断言不测试对象的状态，而是测试与其他对象的交互。这称为后门测试（或交互/行为验证）。

## 底特律
底特律学校的优势在于它相当容易学习并且在绝大多数情况下表现良好。另一个优点是，如果我们还不确切知道应用程序应该如何构建，它非常适合。底特律学校非常适合进行实验，因为无论如何我们都会进行大量重构。底特律学派的一个缺点是我们可能会由于由内而外的开发而产生不必要的死代码。

底特律学派的经典（社交测试）变体也有一个缺点，即我们在测试代码和生产代码之间建立了牢固的联系。视频中讨论的结果是，更改可能会影响许多测试。

## 伦敦 
伦敦学校的优势在于，验收测试与由外向内测试相结合，可以准确地向我们展示接下来需要实施的内容。由于是由外向内测试，我们不会生成任何不需要的功能，因此没有死代码。最大的缺点是重构设计要困难得多，因为当我们更改程序的结构时，对象之间的交互以及测试通常也会发生变化。